'''
This script generates a myHDL-model for the ADC-controller
on the Terasic DE0 Nano board.
The output-file is de0NanoADC_XXXXXXXX.py with XXXXXXXX==sampling sequence.
'''
from array import *
from math import *

''' configuration variables '''
# the channel_scheduler array has to have at least two integers
#channel_scheduler = array('b', [0,0])        # only channel 0 @f_sample_max
#channel_scheduler = array('b', [0,1])      # channel 0 and 1
#channel_scheduler = array('b', [0,1,2,3])  # channel 0,1,2 and 3
channel_scheduler = array('b', [0,1,2,3,4,5,6,7]) # all 8 channels


# generate the scheduler rom model according to the content of
# the configuration variable "channel_scheduler".
scheduler_rom_file = 'scheduler_rom_model.py'
outp = open(scheduler_rom_file, 'w')
outp.write('# generated by de0NanoADC_genModel.py, manual changes are not recommended.\n\n')
outp.write('from myhdl import *\n\n')
outp.write('SAMPLE_SEQUENCE = (')
for i in range(len(channel_scheduler)):
    outp.write(str(channel_scheduler[i]))
    print i
    if i != len(channel_scheduler) - 1:
        outp.write(',')
outp.write(')\n\n')
outp.write("@block\n")
outp.write("def rom(channel, sample_slot, SAMPLE_SEQUENCE):\n")
outp.write("    @always_comb\n")
outp.write("    def read():\n")
outp.write("        channel.next = SAMPLE_SEQUENCE[int(sample_slot)]\n")
outp.write("    return read")
outp.close()

## channel 0 @f_sample_max/2 and channel 1 and 2 @f_sample_max/4
# channel_scheduler = array('b', [0,1,0,2]) # channel 0, 1 and 2

tick_counter_width = 48 #bit


lors =[ 'SCLK_FE1','SCLK_L1','SCLK_RE1','SCLK_H1',
        'SCLK_FE2','SCLK_L2','SCLK_RE2','SCLK_H2',
        'SCLK_FE3','SCLK_L3','SCLK_RE3','SCLK_H3',
        'SCLK_FE4','SCLK_L4','SCLK_RE4','SCLK_H4',
        'SCLK_FE5','SCLK_L5','SCLK_RE5','SCLK_H5',
        'SCLK_FE6','SCLK_L6','SCLK_RE6','SCLK_H6',
        'SCLK_FE7','SCLK_L7','SCLK_RE7','SCLK_H7',
        'SCLK_FE8','SCLK_L8','SCLK_RE8','SCLK_H8',
        'SCLK_FE9','SCLK_L9','SCLK_RE9','SCLK_H9',
        'SCLK_FE10','SCLK_L10','SCLK_RE10','SCLK_H10',
        'SCLK_FE11','SCLK_L11','SCLK_RE11','SCLK_H11',
        'SCLK_FE12','SCLK_L12','SCLK_RE12','SCLK_H12',
        'SCLK_FE13','SCLK_L13','SCLK_RE13','SCLK_H13',
        'SCLK_FE14','SCLK_L14','SCLK_RE14','SCLK_H14',
        'SCLK_FE15','SCLK_L15','SCLK_RE15','SCLK_H15',
        'SCLK_FE16','SCLK_L16','SCLK_RE16','SCLK_H16'] # lors == list of recurring states

CSN = { 'IDLE'      : 1,
        'ASSERT_CS' : 0,
        'SCLK_FE1'  : 0,
        'SCLK_L1'   : 0,
        'SCLK_RE1'  : 0,
        'SCLK_H1'   : 0,
        'SCLK_FE2'  : 0,
        'SCLK_L2'   : 0,
        'SCLK_RE2'  : 0,
        'SCLK_H2'   : 0,
        'SCLK_FE3'  : 0,
        'SCLK_L3'   : 0,
        'SCLK_RE3'  : 0,
        'SCLK_H3'   : 0,
        'SCLK_FE4'  : 0,
        'SCLK_L4'   : 0,
        'SCLK_RE4'  : 0,
        'SCLK_H4'   : 0,
        'SCLK_FE5'  : 0,
        'SCLK_L5'   : 0,
        'SCLK_RE5'  : 0,
        'SCLK_H5'   : 0,
        'SCLK_FE6'  : 0,
        'SCLK_L6'   : 0,
        'SCLK_RE6'  : 0,
        'SCLK_H6'   : 0,
        'SCLK_FE7'  : 0,
        'SCLK_L7'   : 0,
        'SCLK_RE7'  : 0,
        'SCLK_H7'   : 0,
        'SCLK_FE8'  : 0,
        'SCLK_L8'   : 0,
        'SCLK_RE8'  : 0,
        'SCLK_H8'   : 0,
        'SCLK_FE9'  : 0,
        'SCLK_L9'   : 0,
        'SCLK_RE9'  : 0,
        'SCLK_H9'   : 0,
        'SCLK_FE10' : 0,
        'SCLK_L10'  : 0,
        'SCLK_RE10' : 0,
        'SCLK_H10'  : 0,
        'SCLK_FE11' : 0,
        'SCLK_L11'  : 0,
        'SCLK_RE11' : 0,
        'SCLK_H11'  : 0,
        'SCLK_FE12' : 0,
        'SCLK_L12'  : 0,
        'SCLK_RE12' : 0,
        'SCLK_H12'  : 0,
        'SCLK_FE13' : 0,
        'SCLK_L13'  : 0,
        'SCLK_RE13' : 0,
        'SCLK_H13'  : 0,
        'SCLK_FE14' : 0,
        'SCLK_L14'  : 0,
        'SCLK_RE14' : 0,
        'SCLK_H14'  : 0,
        'SCLK_FE15' : 0,
        'SCLK_L15'  : 0,
        'SCLK_RE15' : 0,
        'SCLK_H15'  : 0,
        'SCLK_FE16' : 0,
        'SCLK_L16'  : 0,
        'SCLK_RE16' : 0,
        'SCLK_H16'  : 0 }

SCK = { 'IDLE'      : 1,
        'ASSERT_CS' : 1,
        'SCLK_FE1'  : 0,
        'SCLK_L1'   : 0,
        'SCLK_RE1'  : 1,
        'SCLK_H1'   : 1,
        'SCLK_FE2'  : 0,
        'SCLK_L2'   : 0,
        'SCLK_RE2'  : 1,
        'SCLK_H2'   : 1,
        'SCLK_FE3'  : 0,
        'SCLK_L3'   : 0,
        'SCLK_RE3'  : 1,
        'SCLK_H3'   : 1,
        'SCLK_FE4'  : 0,
        'SCLK_L4'   : 0,
        'SCLK_RE4'  : 1,
        'SCLK_H4'   : 1,
        'SCLK_FE5'  : 0,
        'SCLK_L5'   : 0,
        'SCLK_RE5'  : 1,
        'SCLK_H5'   : 1,
        'SCLK_FE6'  : 0,
        'SCLK_L6'   : 0,
        'SCLK_RE6'  : 1,
        'SCLK_H6'   : 1,
        'SCLK_FE7'  : 0,
        'SCLK_L7'   : 0,
        'SCLK_RE7'  : 1,
        'SCLK_H7'   : 1,
        'SCLK_FE8'  : 0,
        'SCLK_L8'   : 0,
        'SCLK_RE8'  : 1,
        'SCLK_H8'   : 1,
        'SCLK_FE9'  : 0,
        'SCLK_L9'   : 0,
        'SCLK_RE9'  : 1,
        'SCLK_H9'   : 1,
        'SCLK_FE10' : 0,
        'SCLK_L10'  : 0,
        'SCLK_RE10' : 1,
        'SCLK_H10'  : 1,
        'SCLK_FE11' : 0,
        'SCLK_L11'  : 0,
        'SCLK_RE11' : 1,
        'SCLK_H11'  : 1,
        'SCLK_FE12' : 0,
        'SCLK_L12'  : 0,
        'SCLK_RE12' : 1,
        'SCLK_H12'  : 1,
        'SCLK_FE13' : 0,
        'SCLK_L13'  : 0,
        'SCLK_RE13' : 1,
        'SCLK_H13'  : 1,
        'SCLK_FE14' : 0,
        'SCLK_L14'  : 0,
        'SCLK_RE14' : 1,
        'SCLK_H14'  : 1,
        'SCLK_FE15' : 0,
        'SCLK_L15'  : 0,
        'SCLK_RE15' : 1,
        'SCLK_H15'  : 1,
        'SCLK_FE16' : 0,
        'SCLK_L16'  : 0,
        'SCLK_RE16' : 1,
        'SCLK_H16'  : 1 }





output_file = 'scheduler_fsm_model.py'

outp = open(output_file, 'w')
outp.write('# generated by de0NanoADC_genModel.py, manual changes are not recommended.\n')
outp.write('from myhdl import *\n\n')
outp.write("# states of the FSM\n")
outp.write("st = enum( 'IDLE',\n")
outp.write("           'ASSERT_CS',\n")
for i in lors: # iterate list of recurring states
    outp.write("           '" + i)
    if not (i=='SCLK_H16'):
        outp.write("',\n")
    else:
        outp.write("')\n\n\n")





outp.write("@block\n")
outp.write("def DE0NanoADC_driver( clk, reset, spi_csn, spi_din, spi_dout, spi_sck,\n")
outp.write("                       flag_fifo_full, data_packet, push_fifo, error,\n")
outp.write("                       ROM_sample_slot, ROM_channel ):\n")
outp.write("    dout_buffer = Signal(intbv(0)[12:])\n")
outp.write("    tick_counter = Signal(intbv(0)["+ str(tick_counter_width) +":])\n")
outp.write("    tick_counter_buffer = Signal(intbv(0)["+ str(tick_counter_width) +":])\n")
outp.write("    slot_no = Signal(intbv(0)[" + str(int(floor(log(len(channel_scheduler)-1,2)+1))) + ":])\n")
outp.write("    ROM_channel_buffer = Signal(intbv(0)[3:])\n")
outp.write("    data_packet_buffer = Signal(intbv(0)[" + str(4 + tick_counter_width  + 12 ) + ":])\n")
for i in range(12):
    outp.write("    db" + str(i) + "= Signal(bool(0))\n")
outp.write("    state = Signal(st.IDLE)\n\n")

outp.write("    @always_seq(clk.posedge, reset=reset)\n")
outp.write("    def fsm_driver():\n")
outp.write("        if state == st.IDLE:\n")
outp.write("            state.next = st.ASSERT_CS\n")
outp.write("            spi_csn.next = 1\n")
outp.write("            spi_sck.next = 1\n")
outp.write("            spi_din.next = 0\n")
outp.write("        elif state == st.ASSERT_CS:\n")
outp.write("            state.next = st.SCLK_FE1\n")
outp.write("            spi_csn.next = 0\n")
outp.write("            spi_sck.next = 1\n")
outp.write("            spi_din.next = 0\n")

for i in lors: # iterate list of recurring states
    print i
    outp.write("        elif state == st." + i + ":\n")
    if i != 'SCLK_H16':
        outp.write("            state.next = st." +lors[lors.index(i) + 1])
        outp.write("\n")
    else:
        outp.write("            state.next = st.SCLK_FE1\n")               
    outp.write("            tick_counter.next = tick_counter + 1\n")
    outp.write("            spi_csn.next = "+ str(CSN[i]) +"\n")
    outp.write("            spi_sck.next = "+ str(SCK[i]) +"\n")
    if i == 'SCLK_FE1': # increment sample slot pointer
        outp.write("            if ROM_sample_slot < " + str(len(channel_scheduler)-1) + ":\n")
        outp.write("                ROM_sample_slot.next = ROM_sample_slot + 1\n")
        outp.write("            else:\n")
        outp.write("                ROM_sample_slot.next = 0\n")
    elif i == 'SCLK_FE2': # latch current address
        outp.write("            ROM_channel_buffer.next = ROM_channel\n")
    elif i =='SCLK_L2': # ADD2
        outp.write("            spi_din.next = ROM_channel[2]\n")
    elif i =='SCLK_RE2': # ADD2
        outp.write("            spi_din.next = ROM_channel[2]\n")
    elif i == 'SCLK_L3': # ADD1
        outp.write("            spi_din.next = ROM_channel[1]\n")
    elif i =='SCLK_RE3': # ADD1
        outp.write("            spi_din.next = ROM_channel[1]\n")
    elif i == 'SCLK_L4': # ADD0
        outp.write("            spi_din.next = ROM_channel[0]\n")
    elif i =='SCLK_FE4': # latch the current sample tick
        outp.write("            tick_counter_buffer.next = tick_counter\n")
    elif i =='SCLK_RE4': # ADD0
        outp.write("            spi_din.next = ROM_channel[0]\n")
    else:
        outp.write("            spi_din.next = 0\n") # drive DIN LOW(dontcare)

    if i == 'SCLK_L5':
        outp.write("            db11.next = spi_dout\n")
    if i == 'SCLK_L6':
        outp.write("            db10.next = spi_dout\n")            
    if i == 'SCLK_L7':
        outp.write("            db9.next = spi_dout\n")
    if i == 'SCLK_L8':
        outp.write("            db8.next = spi_dout\n")
    if i == 'SCLK_L9':
        outp.write("            db7.next = spi_dout\n")
    if i == 'SCLK_L10':
        outp.write("            db6.next = spi_dout\n")            
    if i == 'SCLK_L11':
        outp.write("            db5.next = spi_dout\n")
    if i == 'SCLK_L12':
        outp.write("            db4.next = spi_dout\n")
    if i == 'SCLK_L13':
        outp.write("            db3.next = spi_dout\n")
    if i == 'SCLK_L14':
        outp.write("            db2.next = spi_dout\n")            
    if i == 'SCLK_L15':
        outp.write("            db1.next = spi_dout\n")
    if i == 'SCLK_L16':
        outp.write("            db0.next = spi_dout\n")
    if i == 'SCLK_FE1':
        outp.write("            data_packet_buffer.next = concat(ROM_channel_buffer[2], ROM_channel_buffer[1], ROM_channel_buffer[0], tick_counter_buffer, db11, db10, db9, db8, db7, db6, db5, db4, db3, db2, db1, db0)\n")
outp.write("        else:\n")
outp.write("            raise ValueError('Undefined state')\n")
outp.write("    return fsm_driver")
outp.close()

